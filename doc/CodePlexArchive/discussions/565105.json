[
  {
    "Id": "1298728",
    "ThreadId": "565105",
    "Html": "<h1>Sharing Knowledge</h1>\nIn this post I'm trying to discuss and analyze the various approaches we can take to implement this functionality, in particular in this post I would address the options we have to share knowledge from CSD to a custom code generator, so I explain some thoughts with pros and cons, as always any feedback is appreciated.\r<br />\n<br />\nTo share knowledge from CSD to a custom code generation strategy (say for example a T4 text template) we have to choose between 2 main ways of doing this: a strongly typed fashion, or a weakly typed fashion.\r<br />\nFollowing I try to address these ways explaining pros and cons.<br />\n<h1>Strongly Typed Fashion</h1>\n<strong>Use CSD Domain classes</strong>\r<br />\nCSD already have its own domain classes to represent our model, this code is generated for us by the DSL tools and we could share domain knowledge with this model.\r<br />\n<br />\n<em>Pros:</em><br />\n<ol>\n<li>We don't have to write any additional code and the classes are generated by the DSL</li>\n<li>We can share same model between <em>Default code generation strategy</em> (the Code DOM one) and a <em>Custom code generation strategy</em></li>\n<li>\nVersioning should be easy (if you don't remove anything from the model, the client code should never break)<br />\n</li>\n</ol>\n<em>Cons:</em><br />\n<ol>\n<li>The model is comlicated by DSL concepts (in base classes) that should not interest the  developer</li>\n<li>We should deploy in some way the dll containing domain model classes (figure out how) because the client should reference this dll from it's project</li>\n<li>The developer should add this dependency to the project even if this is only a <em>Design time</em> dependency (Note this may not be an issue in VS14 or never version because I think MS is working on some sort of design time dependency vs run time dependency, but is definitely an issue on older versions)</li>\n<li>\nActually the dll containing the domain model classes contains a lot of other classes so the developer experience is definitely not nice<br />\n</li>\n</ol>\n<strong>Use a Custom Domain Model library</strong>\r<br />\nWe can create a simplified domain model library containing only the meaningful classes to share domain knowledge to custom code generation strategy\r<br />\n<br />\n<em>Pros:</em><br />\n<ol>\n<li>\nThe developer experience consuming the model could be quite nice, maybe the better one at all<br />\n</li>\n</ol>\n<em>Cons:</em><br />\n<ol>\n<li>We have to create and keep in sync this library with the DSL generated domain model</li>\n<li>Mapping code is tricky and error prone (Automapper mitigates a bit this area)</li>\n<li>We have different model between various code generation strategy</li>\n<li>We have to carefully look at breaking changes and how to handle them</li>\n<li>\nall points 2, 3 and 4 from previous mode still applies.<br />\n</li>\n</ol>\n<strong>Use CodeDOM</strong>\r<br />\nWe can use CodeDOM to share domain knowledge to custom code generation strategy\r<br />\n<br />\n<em>Pros:</em><br />\n<ol>\n<li>We already build a CodeDOM model from our model in current code generation strategy</li>\n<li>Developers of custom code generation strategy does depend on other assemblies</li>\n<li>We don't have to figure out how to deploy/version custom assembly </li>\n<li>\nCodeDOM is around since .NET Framework 1.1 so this can be used across various (read supported) Visual Studio versions.<br />\n</li>\n</ol>\n<em>Cons:</em><br />\n<ol>\n<li>\nThe developer experience is at least ugly and Extract info from CodeDOM is really painful<br />\n</li>\n</ol>\n<strong>Use Roslyn</strong>\r<br />\nWe can use Roslyn to share domain knowledge to custom code generation strategy, in fact our domain is about managed code generation and Roslyn is the latest and greatest Microsoft technology about dealing with managed code (even if maybe is not well suited for source code generation scenarios)\r<br />\n<br />\n<em>Pros:</em>\r<br />\n??\r<br />\n<br />\n<em>Cons:</em><br />\n<ol>\n<li>We should build a Roslyn model from CSD model</li>\n<li>The developer experience is not as bad as using CodeDOM but definitely not good at all</li>\n<li>It's not clear whether or not Roslyn is supported in Visual studio versions prior VS14</li>\n<li>\nTo me seems like take a hammer to crack a nut<br />\n</li>\n</ol>\n<h1>Weakly Typed Fashion</h1>\n<strong>Use XML</strong>\r<br />\nWe can use XML to share domain knowledge to custom code generation strategy\r<br />\n<br />\n<em>Pros:</em><br />\n<ol>\n<li>Everybody knows XML and .NET Framework provides a pretty decent set of XML apis</li>\n<li>There are nothing to deploy outside of the plugin</li>\n<li>\nBreaking changes effect is a lot mitigated (e.g adding a property on a model and consequently add a new element or attribute to an xml node should not break existing client code)<br />\n</li>\n</ol>\n<em>Cons:</em><br />\n<ol>\n<li>XML is verbose</li>\n<li>We have to serialize our model to XML</li>\n<li>\nClient experience is not good as with a strongly typed approach<br />\n</li>\n</ol>\n<strong>Use JSON</strong>\r<br />\nWe can use JSON to share domain knowledge to custom code generation strategy\r<br />\n<br />\n<em>Pros:</em><br />\n<ol>\n<li>There is great support for JSON in .NET ecosystem (I was thinking about JSON.NET)</li>\n<li>There are nothing to deploy outside of the plugin</li>\n<li>\nBreaking changes effect is a lot mitigated (see point 3 of XML pros)<br />\n</li>\n</ol>\n<em>Cons:</em><br />\n<ol>\n<li>We have to serialize our model to JSON</li>\n<li>\nClient experience is not good as with a strongly typed approach<br />\n</li>\n</ol>\nPersonally the idea I like the most is using JSON and create a strongly typed dll on client machine by deploying a set of sources (the classes that builds the strongly typed model) but there are some edges I have to inspect.\r<br />\n<br />\nThese are a first bunch of ideas on how we can share knowledge with custom code generation strategy, of curse there are a lot of others ways (and definitely smarter ones) so I'm asking some feedback on this.\r<br />\n<br />\nRegards, Max<br />\n",
    "PostedDate": "2014-09-03T12:22:25.64-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1299206",
    "ThreadId": "565105",
    "Html": "Max,\r<br />\n<br />\nThis is a very thorough analysis. Many thanks! I've been researching and diagramming the whole CSD solution source code to better see how everything interacts. Once complete (soon), I will be better prepared to provide feedback on your suggestions. I hope others with DSL knowledge will take a look at  your analysis as well and provide some of their own feedback.\r<br />\n<br />\nI'm also going to include my solution analysis documents to this project to help others get a better grasp of this project. <br />\n",
    "PostedDate": "2014-09-04T12:18:24.217-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1303628",
    "ThreadId": "565105",
    "Html": "Max,\r<br />\n<br />\nThe whole process that represents how this extension functions is pretty complex, so it might help to explain some basics. I will try to summarize at a high level, but it is likely you are more familiar with this process than I am (based on your original and well thought out post). Please add corrections if I am wrong.\r<br />\n<br />\n[In the extension code itself]<br />\n<ul>\n<li>We have a DSL model that defines the domain classes that all CSD models will be based from. This includes relationships, constraints, elements of the CSD designer (ConfigurationSection, Comment, etc).</li>\n<li>This DSL model is passed to code generators (T4) to generate these domain classes.</li>\n<li>\nThese classes are compiled and will be used to hold data about the user's CSD model. <br />\n</li>\n</ul>\n[For Developer]<br />\n<ul>\n<li>The domain classes (from above) are filled with data from the developer's .CSD model.</li>\n<li>\nThe code generators use data from these classes to generate the code, schema, etc.<br />\n</li>\n</ul>\nIn your original post, you are describing the process where the domain classes are filled with CSD data to be used (shared knowledge) for code generation? I just want to make sure I understand correctly.<br />\n",
    "PostedDate": "2014-09-11T07:03:02.737-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1303724",
    "ThreadId": "565105",
    "Html": "Hi  andym\r<br />\n<br />\nFirst, I'm not an expert on custom dsl, but I've looked into code for some time so I think I have a higher level idea about what is happening and when, first of all we have our custom tool which VS trigger when file generation is needed (the class is CsdFileGenerator registered with the main package ConfigurationSectionDesignerPackage). \r<br />\nIn order to work properly when you create a new csd file, the file should have the CsdFileGenerator set as a custom tool so visual studio knows which generator invoke.\r<br />\n<br />\nAt this moment we generate 3 different kind of output : cs/vb, xsd, config (note that .diagram are handled by the DSL tools) with 2 different kind of generators: cs/vb is generated by a CodeDOM generator, xsd and config are generated through a T4 template.\r<br />\n<br />\nWhen we start to generate code we load our model using the dsl api, our generators use our model, so the whole point of the post is to find the best possibility to pass our domain knowledge to custom code generator (note that pass out model to custom code generator requires that the client developer should add a reference to the dsl dll)<br />\n",
    "PostedDate": "2014-09-11T11:25:52.12-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1304076",
    "ThreadId": "565105",
    "Html": "That makes perfect sense. Thank you for the clarification Max.<br />\n",
    "PostedDate": "2014-09-12T07:35:21.55-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]