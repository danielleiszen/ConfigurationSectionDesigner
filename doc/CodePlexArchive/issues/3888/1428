<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Configuration.dll" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#
foreach (ConfigurationElement element in this.ConfigurationSectionModel.ConfigurationElements)
{
#>
namespace <#= element.ActualNamespace #>
{
<#
	if (element is ConfigurationSection)
	{
#>
	/// <summary>
	/// <#= element.DocumentationText #>
	/// </summary>
	public partial class <#= element.Name #> : global::System.Configuration.ConfigurationSection
	{
<#
	}
	else if (element is ConfigurationElementCollection)
	{
		ConfigurationElementCollection collectionElement = (ConfigurationElementCollection)element;
		string keyPropertyName = "";
		foreach(ConfigurationProperty prop in collectionElement.ItemType.Properties)
		{
			if(prop.IsKey)
			{
				keyPropertyName = prop.Name;
			}
		}
		string addItemNameParameter = "";
		if(collectionElement.CollectionType == System.Configuration.ConfigurationElementCollectionType.BasicMap || collectionElement.CollectionType == System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate)
		{
			addItemNameParameter = string.Format(", AddItemName = global::{0}.{1}PropertyName", element.FullName, collectionElement.ItemType.Name);
		}
#>
	/// <summary>
	/// <#= element.DocumentationText #>
	/// </summary>
	[global::System.Configuration.ConfigurationCollection(typeof(global::<#= collectionElement.ItemType.FullName #>), CollectionType = global::System.Configuration.ConfigurationElementCollectionType.<#= collectionElement.CollectionType #><#= addItemNameParameter #>)]
	public partial class <#= element.Name #> : global::System.Configuration.ConfigurationElementCollection
	{
		#region Constants
		
		/// <summary>
		/// The XML name of the individual <see cref="global::<#= collectionElement.ItemType.FullName #>"/> instances in this collection.
		/// </summary>
		internal const global::System.String <#= collectionElement.ItemType.Name #>PropertyName = "<#= collectionElement.XmlItemName #>";

		#endregion

		#region Overrides

		/// <summary>
		/// Gets the type of the <see cref="global::System.Configuration.ConfigurationElementCollection"/>.
		/// </summary>
		/// <returns>The <see cref="global::System.Configuration.ConfigurationElementCollectionType"/> of this collection.</returns>
		public override global::System.Configuration.ConfigurationElementCollectionType CollectionType
		{
			get
			{
				return global::System.Configuration.ConfigurationElementCollectionType.<#= collectionElement.CollectionType #>;
			}
		}

		/// <summary>
		/// Indicates whether the specified <see cref="global::System.Configuration.ConfigurationElement"/> exists in the <see cref="global::System.Configuration.ConfigurationElementCollection"/>.
		/// </summary>
		/// <param name="elementName">The name of the element to verify.</param>
		/// <returns>
		/// <see langword="true"/> if the element exists in the collection; otherwise, <see langword="false"/>. The default is <see langword="false"/>.
		/// </returns>
		protected override global::System.Boolean IsElementName(global::System.String elementName)
		{
			return (elementName == <#= collectionElement.ItemType.Name #>PropertyName);
		}

		/// <summary>
		/// Gets the element key for a specified configuration element when overridden in a derived class.
		/// </summary>
		/// <param name="element">The <see cref="global::System.Configuration.ConfigurationElement"/> to return the key for.</param>
		/// <returns>
		/// An <see cref="global::System.Object"/> that acts as the key for the specified <see cref="global::System.Configuration.ConfigurationElement"/>.
		/// </returns>
		protected override global::System.Object GetElementKey(global::System.Configuration.ConfigurationElement element)
		{
			return ((global::<#= collectionElement.ItemType.FullName #>)element).<#= keyPropertyName #>;
		}

		/// <summary>
		/// When overridden in a derived class, creates a new <see cref="global::System.Configuration.ConfigurationElement"/>.
		/// </summary>
		/// <returns>
		/// A new <see cref="global::System.Configuration.ConfigurationElement"/>.
		/// </returns>
		protected override global::System.Configuration.ConfigurationElement CreateNewElement()
		{
			return new global::<#= collectionElement.ItemType.FullName #>();
		}

		#endregion
<#
		if((collectionElement.CodeGenOptions & ConfigurationElementCollectionCodeGenOptions.Indexer) == ConfigurationElementCollectionCodeGenOptions.Indexer)
		{	
#>		
		#region Indexer

		/// <summary>
		/// Gets the <see cref="global::<#= collectionElement.ItemType.FullName #>"/> at the specified index.
		/// </summary>
		/// <param name="index">The index of the <see cref="global::<#= collectionElement.ItemType.FullName #>"/> to retrieve</param>
		public global::<#= collectionElement.ItemType.FullName #> this[int index]
		{
			get
			{
				return (global::<#= collectionElement.ItemType.FullName #>)this.BaseGet(index);
			}
		}

		#endregion
<#
		}
		if((collectionElement.CodeGenOptions & ConfigurationElementCollectionCodeGenOptions.AddMethod) == ConfigurationElementCollectionCodeGenOptions.AddMethod)
		{	
#>		
		#region Add

		/// <summary>
		/// Adds the specified <see cref="global::<#= collectionElement.ItemType.FullName #>"/>.
		/// </summary>
		/// <param name="<#= collectionElement.XmlItemName #>">The <see cref="global::<#= collectionElement.ItemType.FullName #>"/> to add.</param>
		public void Add(global::<#= collectionElement.ItemType.FullName #> <#= collectionElement.XmlItemName #>)
		{
			base.BaseAdd(<#= collectionElement.XmlItemName #>);
		}

		#endregion
<#
		}
		if((collectionElement.CodeGenOptions & ConfigurationElementCollectionCodeGenOptions.RemoveMethod) == ConfigurationElementCollectionCodeGenOptions.RemoveMethod)
		{	
#>		
		#region Remove

		/// <summary>
		/// Removes the specified <see cref="global::<#= collectionElement.ItemType.FullName #>"/>.
		/// </summary>
		/// <param name="<#= collectionElement.XmlItemName #>">The <see cref="global::<#= collectionElement.ItemType.FullName #>"/> to remove.</param>
		public void Remove(global::<#= collectionElement.ItemType.FullName #> <#= collectionElement.XmlItemName #>)
		{
			base.BaseRemove(<#= collectionElement.XmlItemName #>.<#= keyPropertyName #>);
		}

		#endregion
<#
		}
	}
	else
	{
#>
	/// <summary>
	/// <#= element.DocumentationText #>
	/// </summary>
	public partial class <#= element.Name #> : global::System.Configuration.ConfigurationElement
	{
<#
	} // End class header and boilerplate methods.

	foreach (ConfigurationProperty property in element.Properties)
	{
		string defaultValueParameter = "";
		if (property is AttributeProperty)
		{
			AttributeProperty attributeProperty = (AttributeProperty)property;
			if(!string.IsNullOrEmpty(attributeProperty.DefaultValue))
			{
				defaultValueParameter = ", DefaultValue = " + attributeProperty.DefaultValue;
			}
		}
#>
		#region <#= property.Name #> Property
		
		/// <summary>
		/// The XML name of the <see cref="<#= property.Name #>"/> property.
		/// </summary>
		internal const global::System.String <#= property.Name #>PropertyName = "<#= property.XmlName #>";
		
		/// <summary>
		/// <#= property.DocumentationPropertyText #>
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(<#= property.Name #>PropertyName, IsRequired = <#= (property.IsRequired ? "true" : "false") #>, IsKey = <#= (property.IsKey ? "true" : "false") #>, IsDefaultCollection = <#= (property.IsDefaultCollection ? "true" : "false") #><#= defaultValueParameter #>)]
		public global::<#= property.TypeName #> <#= property.Name #>
		{
			get
			{
				return (global::<#= property.TypeName #>)base[<#= property.Name #>PropertyName];
			}
<#
		if (!property.IsReadOnly)
		{
#>
			set
			{
				base[<#= property.Name #>PropertyName] = value;
			}
<#
		}
#>
		}
		
		#endregion

<#
	} // End configuration properties.

	if (element.HasCustomChildElements)
	{
#>
		#region Custom Child Elements

		/// <summary>
		/// Gets a value indicating whether an unknown element is encountered during deserialization.
		/// </summary>
		/// <param name="elementName">The name of the unknown subelement.</param>
		/// <param name="reader">The <see cref="global::System.Xml.XmlReader"/> being used for deserialization.</param>
		/// <returns>
		/// <see langword="true"/> when an unknown element is encountered while deserializing; otherwise, <see langword="false"/>.
		/// </returns>
		/// <exception cref="global::System.Configuration.ConfigurationErrorsException">The element identified by <paramref name="elementName"/> is locked.- or -One or more of the element's attributes is locked.- or -<paramref name="elementName"/> is unrecognized, or the element has an unrecognized attribute.- or -The element has a Boolean attribute with an invalid value.- or -An attempt was made to deserialize a property more than once.- or -An attempt was made to deserialize a property that is not a valid member of the element.- or -The element cannot contain a CDATA or text element.</exception>
		protected override global::System.Boolean OnDeserializeUnrecognizedElement(global::System.String elementName, global::System.Xml.XmlReader reader)
		{
			// IMPORTANT NOTE: The code below does not build by default.
			// You have indicated that this configuration element has
			// custom child elements. Implement the logic to handle unknown
			// deserialized elements by declaring a new method with the
			// signature below in a partial class definition for this element:
			
			// private global::System.Boolean HandleUnrecognizedElement(global::System.String elementName, XmlReader reader)
			
			return HandleUnrecognizedElement(elementName, reader);
		}

		#endregion

<#
	}

	if (element is ConfigurationSection)
	{
		ConfigurationSection configurationSectionElement = (ConfigurationSection)element;
		if((configurationSectionElement.CodeGenOptions & ConfigurationSectionCodeGenOptions.Singleton) == ConfigurationSectionCodeGenOptions.Singleton)
		{
#>
		#region Singleton Instance

		/// <summary>
		/// The XML name of the <#= element.Name #> Configuration Section.
		/// </summary>
		internal const global::System.String <#= element.Name #>SectionName = "<#= configurationSectionElement.XmlSectionName #>";

		/// <summary>
		/// Gets the <#= element.Name #> instance.
		/// </summary>
		public static global::<#= element.FullName #> Instance
		{
			get
			{
				return global::System.Configuration.ConfigurationManager.GetSection(<#= element.Name #>SectionName) as global::<#= element.FullName #>;
			}
		}

		#endregion

<#
		}
		if((configurationSectionElement.CodeGenOptions & ConfigurationSectionCodeGenOptions.XmlnsProperty) == ConfigurationSectionCodeGenOptions.XmlnsProperty)
		{
#>
		#region Xmlns Property
		
		/// <summary>
		/// The XML name of the <see cref="Xmlns"/> property.
		/// </summary>
		internal const global::System.String XmlnsPropertyName = "xmlns";
		
		/// <summary>
		/// Gets the XML namespace of this Configuration Section.
		/// </summary>
		/// <remarks>
		/// This property makes sure that if the configuration file contains the XML namespace,
		/// the parser doesn't throw an exception because it encounters the unknown "xmlns" attribute.
		/// </remarks>
		[global::System.Configuration.ConfigurationProperty(XmlnsPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public global::System.String Xmlns
		{
			get
			{
				return (global::System.String)base[XmlnsPropertyName];
			}
		}
		
		#endregion
<#
		}
	}
#>
	}
}

<#
} // End configuration element.

foreach (TypeDefinition type in this.ConfigurationSectionModel.TypeDefinitions)
{
	EnumeratedType enumType = type as EnumeratedType;
	if (enumType != null && ((enumType.CodeGenOptions & TypeDefinitionCodeGenOptions.TypeDefinition) == TypeDefinitionCodeGenOptions.TypeDefinition))
	{
		string enumDocumentation = enumType.Documentation;
		if (string.IsNullOrEmpty(enumDocumentation) )
		{
			enumDocumentation = enumType.Name + ".";
		}
#>
namespace <#= enumType.Namespace #>
{
	/// <summary>
	/// <#= enumDocumentation #>
	/// </summary>
<#
		if (enumType.IsFlags)
		{
#>
	[global::System.FlagsAttribute()]
<#
		} // End EnumeratedType.IsFlags
#>
	public enum <#= enumType.Name #>
	{
<#
		foreach (EnumerationLiteral literal in enumType.Literals)
		{
			string literalDocumentation = literal.Documentation;
			if (string.IsNullOrEmpty(literalDocumentation) )
			{
				literalDocumentation = literal.Name + ".";
			}
			string literalDefinition = literal.Name;
			if (!string.IsNullOrEmpty(literal.Value))
			{
				literalDefinition = string.Format("{0} = {1}", literalDefinition, literal.Value);
			}
			if (literal != enumType.Literals[enumType.Literals.Count - 1])
			{
				literalDefinition += ",";
			}
#>
		/// <summary>
		/// <#= literalDocumentation #>
		/// </summary>
		<#= literalDefinition #>
		
<#
		} // End EnumerationLiteral
#>
	}
}

<#
	} // End EnumeratedType
} // End TypeDefinition
#>